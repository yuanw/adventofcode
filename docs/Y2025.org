* Day 1
** Haskell

we need to turn "L68" -> ("L", 68)

> how to apply two functions for a tuple of 2 in haskell

⏺ There are several elegant ways to apply two functions to a tuple in Haskell:

  Using Control.Arrow operators

  The *** operator - applies different functions to each element:
  import Control.Arrow ((***))

  -- Apply f to first element, g to second element
  (+1) *** (*2) $ (3, 4)  -- (4, 8)

  -- Real example from AoC-style code
  (read :: String -> Int) *** length $ ("42", "hello")  -- (42, 5)

  The &&& operator - applies two functions to the same input and creates a tuple:
  import Control.Arrow ((&&&))

  -- Your code already uses this pattern in Y2023/Day1.hs!
  readInt = (\(x, y) -> x * 10 + y) . (readFromLeft &&& readFromRight)

  -- Another example
  (+1) &&& (*2) $ 5  -- (6, 10)

  Using Data.Bifunctor

  The bimap function - applies functions to both elements:
  import Data.Bifunctor (bimap)

  bimap (+1) (*2) (3, 4)  -- (4, 8)
  bimap read length ("42", "hello")  -- (42, 5)

  The first and second functions - apply to one element only:
  import Data.Bifunctor (first, second)

  first (+1) (3, 4)   -- (4, 4)
  second (*2) (3, 4)  -- (3, 8)

  Pattern Matching (manual approach)

  applyBoth :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
  applyBoth f g (x, y) = (f x, g y)

  applyBoth (+1) (*2) (3, 4)  -- (4, 8)

  ★ Insight ─────────────────────────────────────
  - *** (from Arrow) and bimap (from Bifunctor) are functionally equivalent for tuples
  - Your codebase already uses Arrow operators - see Y2023/Day1.hs:22 where &&& combines two parsing functions
  - The Arrow operators are more concise in point-free style: map (f *** g) vs map (bimap f g)




readTuple :: String ->  (Char, Int)
readTuple = fromJust . fmap (second read) . uncons


  -- What you tried (doesn't work):
  -- let a ::Int = 101, b ::Int= 100 :: Int; a `mod` b

  -- Correct version 1 (semicolons):
  let a :: Int; a = 101; b :: Int; b = 100 in a `mod` b

  -- Correct version 2 (inline annotations):
  let a = 101 :: Int; b = 100 :: Int in a `mod` b


    What was wrong:
  The type signature indicated accum takes two parameters (Int -> [(Char, Int)] -> Int), but the point-free implementation tried to compose functions incorrectly. You can't compose foldr (...) (which
  returns a multi-parameter function) with a single-parameter lambda using ..

  The fix:
  -- Before (broken):
  accum = (let a :: Int = 100 in \(x) -> x `mod` a) . foldr (\(d,n) acc -> ...)

  -- After (working):
  accum start xs = (let a :: Int = 100 in \x -> x `mod` a) (foldr (\(d, n) acc -> ...) start xs)

  Made the parameters start and xs explicit, then applied the result of foldr to the lambda.

  ★ Insight ─────────────────────────────────────
  - Point-free style with multi-parameter functions requires careful thinking about currying
  - Function composition f . g works when g's output type matches f's input type
  - When types don't align for composition, making parameters explicit is the clearest solution


  ⏺ ✅ Build successful! Fixed the bug in the accum function.

  What was wrong:
  1. foldr processes right-to-left - This meant rotations were applied in reverse order
  2. Parameter order - foldr and foldl have opposite parameter orders in their lambda functions

  The fix:
  -- Before (wrong - processes backwards):
  foldr (\(d, n) (acc, count) -> ...) (start, 0)

  -- After (correct - processes forwards):
  foldl (\(acc, count) (d, n) -> ...) (start, 0)

  With your test data starting at 50:
  - L68: 50 - 68 = -18
  - L30: -18 - 30 = -48
  - R48: -48 + 48 = 0 ✓ (count increments!)
  - L5: 0 - 5 = -5

  Now the count will increment correctly when passing through 0 or multiples of 100.

  ★ Insight ─────────────────────────────────────
  - foldr: lambda is \element accumulator -> ..., processes right-to-left
  - foldl: lambda is \accumulator element -> ..., processes left-to-right
  - For sequential operations where order matters (like applying rotations), use foldl
